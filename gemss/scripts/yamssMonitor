#!/bin/bash
############################################################################
# Copyright 2008-2010 Istituto Nazionale di Fisica Nucleare
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
############################################################################

source /etc/profile

. /usr/local/yamss/bin/yamssCommands

check_drain_file() {
   if [ -f $1 ]; then  
      return 0
   fi
   return 1
}

firstrun=1
let hbnum=1

while [ 1 ]; do

  # get existing filesystems from /etc/fstab
  cat /etc/fstab | while read -r myline; do
    dev=$(echo "$myline" | awk '{print $1}')
    devf=$(echo "$dev" | cut -c1)
    mntpoint=$(echo "$myline" | awk '{print $2}')
    fstype=$(echo "$myline" | awk '{print $3}')
    if [ "$devf"x = "#"x -o "$fstype"x != "gpfs"x ]; then
      continue
    fi
    devname=$(echo $dev|cut -d/ -f3)
    
    # yamssRecallDaemon must start before the filesystem is mounted
    # note that for the moment the recall daemon will start only for the first gpfs filesystem in fstab
    let nrun=0
    for pids in $($pidof yamssRecallDaemon); do
      let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$mntpoint$" | wc -l)
    done
    if [ "$nrun"x = "0x" ]; then
      $yamssRecallDaemon $mntpoint 2>&1 | $yamssLogger $devname yamssRecallDaemon monitor.log $mntpoint &
    fi
    break

  done

  # loop over all mounted filesystems
  while read -r myline; do
     devname=$(basename -- $(echo "$myline"|awk '{print $1}'))
     mntpoint=$(echo "$myline"|awk '{print $2}')
     fstype=$(echo "$myline"|awk '{print $3}')

     # if filesystem is not a gpfs continue
     if [ "$fstype"x != "gpfsx" ]; then
       continue
     fi

     # if configuration file does not exist continue
     if [ ! -f $mntpoint/system/YAMSS_CONFIG/hsmConfig ]; then
       continue
     fi

     # give startup message (if filesystem is mounted)
     if [ $firstrun = "1" ]; then
        printf "$$\nProcess has started\n" | $yamssLogger $devname yamssMonitor monitor.log
     fi

     # start nailgun, but log just on the first filesystem log file (should fix it for multiple filesystems)
     let nrun=0
     for pids in $($pidof java); do
        let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n2 | head -n1 | egrep "com.martiansoftware.nailgun.NGServer" | wc -l)
     done
     if [ "$nrun"x = "0x" ]; then
        MYPID=$$
        (echo $MYPID; $ngserver) | $yamssLogger $devname yamssMonitor monitor.log &
     fi 

     # log heartbeat
     if [ $hbnum -eq 50 ]; then
        printf "$$\nProcess is running\n" | $yamssLogger $devname yamssMonitor monitor.log 
     fi 

     if [ "$MODULE_REMOVE"x = "yesx" ]; then 
       # start yamssProcessRemove process for this filesystem if not yet running
       let nrun=0
       for pids in $($pidof -x yamssProcessRemove); do
          let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
       done
       if [ "$nrun"x = "0x" ]; then
          $yamssProcessRemove $devname 2>&1 | $yamssLogger $devname yamssProcessRemove monitor.log &
       fi
     fi

     if [ "$MODULE_STUBBIFY"x = "yesx" ]; then
       # start yamssProcessStubbify process for this filesystem if not yet running
       let nrun=0
       for pids in $($pidof -x yamssProcessStubbify); do
          let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
       done
       if [ "$nrun"x = "0x" ]; then
          $yamssProcessStubbify $devname 2>&1 | $yamssLogger $devname yamssProcessStubbify monitor.log &
       fi
     fi

     if [ "$MODULE_UPDATE_DAMAGED_FILES"x = "yesx" ]; then
       # start yamssUpdateDamagedFiles for this filesystem if not yet running
       let nrun=0
       for pids in $($pidof -x yamssUpdateDamagedFiles); do
         let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
       done
       if [ "$nrun"x = "0x" ]; then
          $yamssUpdateDamagedFiles $devname 2>&1 | $yamssLogger $devname yamssUpdateDamagedFiles monitor.log &
       fi
     fi

     if [ "$MODULE_UPDATE_VOLUMES_IN_ERROR_STATE"x = "yesx" ]; then
       # start yamssUpdateVolumesInErrorState for this filesystem if not yet running
       let nrun=0
       for pids in $($pidof -x yamssUpdateVolumesInErrorState); do
          let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
       done
       if [ "$nrun"x = "0x" ]; then
          $yamssUpdateVolumesInErrorState $devname 2>&1 | $yamssLogger $devname yamssUpdateVolumesInErrorState monitor.log &
       fi
     fi

     if [ "$MODULE_STAT_MANAGER"x = "yesx" ]; then
       # start yamssStatManager for this filesystem if not yet running
       let nrun=0
       for pids in $($pidof -x yamssStatManager); do
         let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
       done
       if [ "$nrun"x = "0x" ]; then
         $yamssStatManager $devname 2>&1 | $yamssLogger $devname yamssStatManager monitor.log &
       fi
     fi

     # Check if drain file is present
     if check_drain_file $mntpoint/system/YAMSS_DRAIN/recall.drain; then
       continue
     fi

     # execute configuration file
     . $mntpoint/system/YAMSS_CONFIG/hsmConfig

     # start yamssStartPolicy process for this filesystem if not yet running
     let nrun=0
     for pids in $($pidof -x yamssStartPolicy); do
        let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
     done
     if [ "$nrun"x = "0x" ]; then
        $yamssStartPolicy $devname 2>&1 | $yamssLogger $devname yamssStartPolicy startpolicy.log &
     fi

     # start yamssReorderRecall process for this filesystem if not yet running
     let nrun=0
     for pids in $($pidof -x yamssReorderRecall); do
        let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
     done
     if [ "$nrun"x = "0x" ]; then
        $yamssReorderRecall $devname 2>&1 | $yamssLogger $devname yamssReorderRecall monitor.log &
     fi

     # check if this node is within the recall node list
     hostnam=$(hostname|cut -d. -f1)
     isin=0
     for nodes in $(echo $RECALL_NODE_LIST|tr "," " "|cut -d. -f1); do
        if [ "$hostnam"x = "$nodes"x ]; then
           isin=1
           break
        fi
     done
     if [ "$isin"x = "0x" ]; then
        continue
     fi

     # start yamssProcessRecall processes for this filesystem if not yet running
     let nrun=0
     for pids in $($pidof -x yamssProcessRecall); do
        let nrun=$nrun+$(cat /proc/$pids/cmdline 2>/dev/null | tr "\0" "\n" | tail -n1 | egrep "^$devname$" | wc -l)
     done
     # note that two yamssProcessRecall processes are returned for each recall
     let nrun=$nrun/2+1
     for nlau in $(seq $nrun $RECALL_RUNNING_THREADS); do
        $yamssProcessRecall $devname 2>&1 | $yamssLogger $devname yamssProcessRecall monitor.log &
     done
     
  done < /proc/mounts

  sleep 5

  # reset first run flag
  firstrun=0

  # increase heartbeat control counter
  let hbnum=$hbnum+1
  if [ $hbnum -gt 50 ]; then
    let hbnum=1
  fi

done
